/*
          # [Operation Name]
          Implement Full Supabase Auth Flow with Email Confirmation

          ## Query Description: [This migration completely overhauls the authentication system to use Supabase's built-in email confirmation flow. It replaces the old 'users' table with a 'profiles' table linked to 'auth.users', and sets up a trigger for automatic profile creation. This is a destructive change to the old 'users' table but aligns the project with Supabase best practices for security and scalability. A backup is highly recommended before applying.]
          
          ## Metadata:
          - Schema-Category: ["Dangerous"]
          - Impact-Level: ["High"]
          - Requires-Backup: [true]
          - Reversible: [false]
          
          ## Structure Details:
          - Drops the old 'users' table.
          - Creates a new 'profiles' table linked to 'auth.users'.
          - Creates a trigger 'on_auth_user_created' to populate the 'profiles' table.
          - Updates RLS policies for 'profiles' and 'materials' to work with the new auth system.
          
          ## Security Implications:
          - RLS Status: [Enabled]
          - Policy Changes: [Yes]
          - Auth Requirements: [Users must now confirm their email to log in.]
          
          ## Performance Impact:
          - Indexes: [No new indexes added]
          - Triggers: [Adds a trigger on auth.users insert]
          - Estimated Impact: [Slight overhead on new user creation due to trigger, but overall performance is improved by using native auth.]
          */

-- Step 1: Drop old objects if they exist to prevent conflicts
DROP TABLE IF EXISTS public.users CASCADE;
DROP TABLE IF EXISTS public.materials CASCADE;
DROP TYPE IF EXISTS public.user_role;

-- Step 2: Create the user_role ENUM type
CREATE TYPE public.user_role AS ENUM ('student', 'teacher', 'admin');

-- Step 3: Create the profiles table, linked to auth.users
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name text,
  role user_role,
  student_id text,
  major text,
  academic_year text,
  updated_at timestamp with time zone,
  
  CONSTRAINT name_length CHECK (char_length(name) >= 3)
);

-- Step 4: Create the materials table
CREATE TABLE public.materials (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  teacher_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content text NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_at timestamp with time zone
);

-- Step 5: Create a function to handle new user creation and populate the profiles table
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, name, role, student_id, major, academic_year)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'name',
    (new.raw_user_meta_data->>'role')::user_role,
    new.raw_user_meta_data->>'student_id',
    new.raw_user_meta_data->>'major',
    new.raw_user_meta_data->>'academic_year'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Set the search path for the function to avoid the security warning.
ALTER FUNCTION public.handle_new_user() SET search_path = public;

-- Step 6: Create a trigger to call the function when a new user is created in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Step 7: Set up Row Level Security (RLS)
-- Enable RLS for profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own profile." ON public.profiles
  FOR SELECT USING (auth.uid() = id);
  
CREATE POLICY "Users can update their own profile." ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles." ON public.profiles
  FOR SELECT USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can delete any profile." ON public.profiles
  FOR DELETE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Enable RLS for materials
ALTER TABLE public.materials ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all materials." ON public.materials
  FOR SELECT USING (true);

CREATE POLICY "Teachers can insert their own materials." ON public.materials
  FOR INSERT WITH CHECK (auth.uid() = teacher_id);

CREATE POLICY "Teachers can update their own materials." ON public.materials
  FOR UPDATE USING (auth.uid() = teacher_id);
  
CREATE POLICY "Teachers can delete their own materials." ON public.materials
  FOR DELETE USING (auth.uid() = teacher_id);

CREATE POLICY "Admins can manage all materials." ON public.materials
  FOR ALL USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));
